interface rcConfig {
    void rcConfig();

    attribute long width;
    attribute long height;
    attribute long tileSize;
    attribute long borderSize;
    attribute float cs;
    attribute float ch;
    attribute float[] bmin; 
    attribute float[] bmax;
    attribute float walkableSlopeAngle;
    attribute long walkableHeight;
    attribute long walkableClimb;
    attribute long walkableRadius;
    attribute long maxEdgeLen;
    attribute float maxSimplificationError;
    attribute long minRegionArea;
    attribute long mergeRegionArea;
    attribute long maxVertsPerPoly;
    attribute float detailSampleDist;
    attribute float detailSampleMaxError;
};

interface dtMeshHeader {
    attribute long magic;
    attribute long version;
    attribute long x;
    attribute long y;
    attribute long layer;
    attribute unsigned long userId;
    attribute long polyCount;
    attribute long vertCount;
    attribute long maxLinkCount;
    attribute long detailMeshCount;
    attribute long detailVertCount;
    attribute long detailTriCount;
    attribute long bvNodeCount;
    attribute long offMeshConCount;
    attribute long offMeshBase;
    attribute float walkableHeight;
    attribute float walkableRadius;
    attribute float walkableClimb;
    attribute float[] bmin;
    attribute float[] bmax;
    attribute float bvQuantFactor;
};

interface dtPoly {
    attribute unsigned long firstLink;
    attribute unsigned short[] verts;
    attribute unsigned short[] neis;
    attribute unsigned short flags;
    attribute octet vertCount;
    attribute octet areaAndtype;

    void setArea(octet a);
    void setType(octet a);
    octet getType();
    octet getArea();
};

interface dtPolyDetail {
    attribute long vertBase;
    attribute long triBase;
    attribute octet vertCount;
    attribute octet triCount;
};

interface dtLink {
    attribute unsigned long ref;
    attribute unsigned long next;
    attribute octet edge;
    attribute octet side;
    attribute octet bmin;
    attribute octet bmax;
};

interface dtBVNode {
    attribute unsigned short[] bmin;
    attribute unsigned short[] bmax;
    attribute long i;
};

interface dtOffMeshConnection {
    attribute float[] pos;
    attribute float rad;
    attribute unsigned short poly;
    attribute octet flags;
    attribute octet side;
    attribute unsigned long userId;
};

interface dtMeshTile {
    attribute unsigned long salt;

    attribute long linksFreeList;
    attribute dtMeshHeader header;
    [Value] attribute dtPoly[] polys;
    attribute float[] verts;
    [Value] attribute dtLink[] links;
    [Value] attribute dtPolyDetail[] detailMeshes;
    attribute float[] detailVerts;
    attribute octet[] detailTris;
    [Value] attribute dtBVNode[] bvTree;
    [Value] attribute dtOffMeshConnection[] offMeshCons;
    attribute octet[] data;
    attribute long dataSize;
    attribute long flags;
    attribute dtMeshTile next; 
};

interface dtNavMesh {
};

interface dtNavMeshCreateParams {
    void dtNavMeshCreateParams();

    readonly attribute unsigned short[] verts;
    attribute long vertCount;
    readonly attribute unsigned short[] polys;
    readonly attribute unsigned short[] polyFlags;
    readonly attribute octet[] polyAreas;
    attribute long polyCount;
    attribute long nvp;

    readonly attribute unsigned long[] detailMeshes;
    readonly attribute float[] detailVerts;
    attribute long detailVertsCount;
    readonly attribute octet[] detailTris;
    attribute long detailTriCount;

    readonly attribute float[] offMeshConVerts;
    readonly attribute float[] offMeshConRad;
    readonly attribute unsigned short[] offMeshConFlags;
    readonly attribute octet[] offMeshConAreas;
    readonly attribute octet[] offMeshConDir;
    readonly attribute unsigned long[] offMeshConUserID;
    attribute long offMeshConCount;

    attribute unsigned long userId;
    attribute long tileX;
    attribute long tileY;
    attribute long tileLayer;
    attribute float[] bmin;
    attribute float[] bmax;

    attribute float walkableHeight;
    attribute float walkableRadius;
    attribute float walkableClimb;
    attribute float cs;
    attribute float ch;

    attribute boolean buildBvTree;
};

interface dtObstacleRef {

};

interface dtCompressedTileRef {

};

interface dtNavMeshParams {
    void dtNavMeshParams();

    attribute float[] orig;
    attribute float tileWidth;
    attribute float tileHeight;
    attribute long maxTiles;
    attribute long maxPolys;
};

interface dtCrowdAgentParams {
    void dtCrowdAgentParams();

    /// Agent radius. [Limit: >= 0]
    attribute float radius;                        
    
    /// Agent height. [Limit: > 0]
    attribute float height;                        
    
    /// Maximum allowed acceleration. [Limit: >= 0]
    attribute float maxAcceleration;                
    
    /// Maximum allowed speed. [Limit: >= 0]
    attribute float maxSpeed;                        

    /// Defines how close a collision element must be before it is considered for steering behaviors. [Limits: > 0]
    attribute float collisionQueryRange;

    /// The path visibility optimization range. [Limit: > 0]
    attribute float pathOptimizationRange;        

    /// How aggresive the agent manager should be at avoiding collisions with this agent. [Limit: >= 0]
    attribute float separationWeight;

    /// Flags that impact steering behavior. (See: #UpdateFlags)
    attribute octet updateFlags;

    /// The index of the avoidance configuration to use for the agent. 
    /// [Limits: 0 <= value <= #DT_CROWD_MAX_OBSTAVOIDANCE_PARAMS]
    attribute octet obstacleAvoidanceType;    

    /// The index of the query filter used by this agent.
    attribute octet queryFilterType;

    /// User defined data attached to the agent.
    attribute VoidPtr userData;
};

interface CreateNavMeshDataResult {
    attribute boolean success;
    attribute octet[] navMeshData;
    attribute long navMeshDataSize;
};

interface NavMeshBuilder {
    void NavMeshBuilder();

    [Value] CreateNavMeshDataResult createNavMeshData([Ref] dtNavMeshCreateParams params);
};

interface NavMeshGeneratorResult {
    attribute boolean success;
    [Const, Ref] NavMesh getNavMesh();
    [Const, Ref] TileCache getTileCache();
};

interface NavMeshGenerator {
    void NavMeshGenerator();

    [Value] NavMeshGeneratorResult generate([Const] float[] positions, [Const] long positionCount, [Const] long[] indices, [Const] long indexCount, [Const, Ref] rcConfig config);
};

interface NavMeshImporterResult {
    [Const, Ref] NavMesh getNavMesh();
    [Const, Ref] TileCache getTileCache();
};

interface NavMeshImporter {
    void NavMeshImporter();

    [Value] NavMeshImporterResult importNavMesh(NavMeshExport data);
};

interface NavMeshExport {
    attribute any dataPointer;
    attribute long size;

    void NavMeshExport();
};

interface NavMeshExporter {
    void NavMeshExporter();

    [Value] NavMeshExport exportNavMesh(NavMesh navMesh, TileCache tileCache);
    void freeNavMeshExport(NavMeshExport navMeshExport);
};

interface Vec3 {
    attribute float x;
    attribute float y;
    attribute float z;

    void Vec3();
    void Vec3(float x, float y, float z);
};

interface Triangle {
    void Triangle();

    [Const, Ref] Vec3 getPoint(long n);
};

interface DebugNavMesh {
    void DebugNavMesh();

    long getTriangleCount();
    [Const, Ref] Triangle getTriangle(long n);
};

interface NavMeshAddTileResult {
    attribute unsigned long status;
    attribute unsigned long tileRef; 
};

interface NavMeshRemoveTileResult {
    attribute unsigned long status;
    attribute octet[] data;
    attribute long dataSize;
};

interface NavMeshCalcTileLocResult {
    attribute long tileX;
    attribute long tileY;
};

interface NavMeshGetTilesAtResult {
    [Value, Const] readonly attribute dtMeshTile[] tiles;
    attribute long tileCount; 
};

interface NavMeshGetTileAndPolyByRefResult {
    attribute unsigned long status;
    [Const] attribute dtMeshTile tile;
    [Const] attribute dtPoly poly;
};

interface NavMeshGetOffMeshConnectionPolyEndPointsResult {
    attribute unsigned long status;
    [Const] attribute float[] startPos;
    [Const] attribute float[] endPos;
};

interface NavMeshGetPolyFlagsResult {
    attribute unsigned long status;
    attribute unsigned short flags;
};

interface NavMeshGetPolyAreaResult {
    attribute unsigned long status;
    attribute octet area;
};

interface NavMeshStoreTileStateResult {
    attribute unsigned long status;
    attribute octet[] data;
    attribute long dataSize;
};

interface NavMesh {
    void NavMesh();

    boolean initSolo(octet[] data, [Const] long dataSize, [Const] long flags);    
    boolean initTiled([Const] dtNavMeshParams params);
    [Value] NavMeshAddTileResult addTile(octet[] data, long dataSize, long flags, unsigned long lastRef);
    [Value] NavMeshRemoveTileResult removeTile(unsigned long ref);
    [Value] DebugNavMesh getDebugNavMesh();
    dtNavMesh getNavMesh();
    [Value] NavMeshCalcTileLocResult calcTileLoc([Const] float[] pos);
    [Const] dtMeshTile getTileAt([Const] long x, [Const] long y, [Const] long layer);
    [Value] NavMeshGetTilesAtResult getTilesAt([Const] long x, [Const] long y, [Const] long maxTiles);
    unsigned long getTileRefAt(long x, long y, long layer);
    unsigned long getTileRef([Const] dtMeshTile tile);
    [Const] dtMeshTile getTileByRef(unsigned long ref);
    long getMaxTiles();
    [Const] dtMeshTile getTile(long i);
    [Value] NavMeshGetTileAndPolyByRefResult getTileAndPolyByRef([Const] unsigned long ref);
    [Value] NavMeshGetTileAndPolyByRefResult getTileAndPolyByRefUnsafe([Const] unsigned long ref);
    boolean isValidPolyRef(unsigned long ref);
    unsigned long getPolyRefBase([Const] dtMeshTile tile);
    [Value] NavMeshGetOffMeshConnectionPolyEndPointsResult getOffMeshConnectionPolyEndPoints(unsigned long prevRef, unsigned long polyRef);
    [Const] dtOffMeshConnection getOffMeshConnectionByRef(unsigned long ref);
    unsigned long setPolyFlags(unsigned long ref, unsigned short flags);
    [Value] NavMeshGetPolyFlagsResult getPolyFlags(unsigned long ref);
    unsigned long setPolyArea(unsigned long ref, octet area);
    [Value] NavMeshGetPolyAreaResult getPolyArea(unsigned long ref);
    unsigned long getTileStateSize([Const] dtMeshTile tile);
    [Value] NavMeshStoreTileStateResult storeTileState([Const] dtMeshTile tile, [Const] long maxDataSize);
    unsigned long restoreTileState(dtMeshTile tile, [Const] octet[] data, [Const] long maxDataSize);
    void destroy();
};

interface NavPath
{
    long getPointCount();
    [Const, Ref] Vec3 getPoint(long n);
};

interface NavMeshQuery {
    void NavMeshQuery(NavMesh navMesh, [Const] long maxNodes);

    void destroy();
    [Value] Vec3 getClosestPoint([Const, Ref] Vec3 position);
    [Value] Vec3 getRandomPointAround([Const, Ref] Vec3 position, float maxRadius);
    [Value] Vec3 moveAlong([Const, Ref] Vec3 position, [Const, Ref] Vec3 destination);
    [Value] NavPath computePath([Const, Ref] Vec3 start, [Const, Ref] Vec3 end);
    void setDefaultQueryExtent([Const, Ref] Vec3 extent);
    [Value] Vec3 getDefaultQueryExtent();
};

interface dtTileCacheParams {
    attribute float[] orig;
    attribute float cs;
    attribute float ch;
    attribute long width;
    attribute long height;
    attribute float walkableHeight;
    attribute float walkableRadius;
    attribute float walkableClimb;
    attribute float maxSimplificationError;
    attribute long maxTiles;
    attribute long maxObstacles;
};

interface TileCacheAddTileResult {
    attribute unsigned long status;
    attribute unsigned long tileRef;
};

interface TileCacheUpdateResult {
    attribute unsigned long status;
    attribute boolean upToDate;
};

interface TileCache {
    void TileCache();

    boolean init([Const, Ref] dtTileCacheParams params);
    [Value] TileCacheAddTileResult addTile(octet[] data, [Const] long dataSize, octet flags);
    unsigned long buildNavMeshTile([Const] dtCompressedTileRef ref, NavMesh navMesh);
    unsigned long buildNavMeshTilesAt([Const] long tx, [Const] long ty, NavMesh navMesh);
    [Value] TileCacheUpdateResult update(NavMesh navMesh);
    dtObstacleRef addCylinderObstacle([Const, Ref] Vec3 position, float radius, float height);
    dtObstacleRef addBoxObstacle([Const, Ref] Vec3 position, [Const, Ref] Vec3 extent, float angle);
    void removeObstacle(dtObstacleRef obstacle);
    void destroy();
};

interface Crowd {
    void Crowd([Const] long maxAgents, [Const] float maxAgentRadius, NavMesh navMesh);

    void destroy();
    long addAgent([Const, Ref] Vec3 position, [Const] dtCrowdAgentParams params);
    void removeAgent([Const] long idx);
    void update([Const] float dt);
    long getAgentCount();
    long getActiveAgentCount();
    [Value] Vec3 getAgentPosition([Const] long idx);
    [Value] Vec3 getAgentVelocity([Const] long idx);
    [Value] Vec3 getAgentNextTargetPath([Const] long idx);
    long getAgentState([Const] long idx);
    boolean overOffMeshConnection([Const] long idx);
    void agentGoto([Const] long idx, [Const, Ref] Vec3 destination);
    void agentResetMoveTarget([Const] long idx);
    void agentTeleport([Const] long idx, [Const, Ref] Vec3 destination);
    [Value] dtCrowdAgentParams getAgentParameters([Const] long idx);
    void setAgentParameters([Const] long idx, [Const] dtCrowdAgentParams params);
    void setDefaultQueryExtent([Const, Ref] Vec3 extent);
    [Value] Vec3 getDefaultQueryExtent();
    [Value] NavPath getCorners([Const] long idx);
};

interface DtStatus {
    void DtStatus();

    attribute long FAILURE;
    attribute long SUCCESS;
    attribute long IN_PROGRESS;
    attribute long STATUS_DETAIL_MASK;
    attribute long WRONG_MAGIC;
    attribute long WRONG_VERSION;
    attribute long OUT_OF_MEMORY;
    attribute long INVALID_PARAM;
    attribute long BUFFER_TOO_SMALL;
    attribute long OUT_OF_NODES;
    attribute long PARTIAL_RESULT;
    attribute long ALREADY_OCCUPIED;

    boolean statusSucceed(unsigned long status);
    boolean statusFailed(unsigned long status);
    boolean statusInProgress(unsigned long status);
    boolean statusDetail(unsigned long status, unsigned long detail);
};
